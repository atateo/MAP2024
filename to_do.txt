1) impostare srtruttura base
    - aggiungere log4j per impostare i messaggi di log dell'applicazione
    - aggiungere package utility per eventuali classi di utilità (cripaggio password, gestione dei file, ecc...)
    - meccanismo di memorizzazione dei progressi del gioco su file (con tutto ciò che comporta)
    - valutare la possibilità di creare un pannello di controllo (login, gestione utente, settaggi del gioco, ecc...)
    - valutare la possibilità di poter gestire diverse storie (avventure o ciò che sarà deciso di utilizzare come argomento del gioco)
    - valutare l'utilizzo di grafica (immagini o icone, compatibilimente con quanto è permesso dalle classi java swing)
2) definire la modalità di gestione della gui
    - implementare le classi mediante swing, i panel con tutti gli elementi necessari allo svolgimento del gioco (label, bottoni, action, ecc...)
    - agganciare i metodi o le API che consentono al gioco di avanzare nelle fasi
    - definire le interfacce per la gestione delle componenti del gioco
3) impostare i crud sulle tabelle che serviranno per comporre il gioco
    - verificare se va implementato con framework (JPA, hibernate, ecc.. o con PreparedStatement)
    - nel caso creare le classi DAO e le implementazioni (esempio al link https://www.geeksforgeeks.org/jdbc-using-model-object-and-singleton-class/)
4) creare una classe motore che prenda dal database il contenuto da renderizzare e mostri l'evoluzione del gioco nella gui (si aggancia al punto 2 e dipende dalla 
    scelta che effettueremo)
5) creare un server web che esponga delle API (verificare la fattibilità di utilizzare le API per alimentare il gioco, in questo caso avremmo un'app client server ma 
    gli stessi convivrebbero sullo stesso progetto)
6) sistemare le classi aggiungendo i commenti javadocs (sicuramente torneranno utili per creare la documentazione)
7) realizzare documentazione di progetto (a tale riguardo verificare come si procede, cosa va consegnato?)

IMPORTANTE:
-   ricordarsi di commentare il codice opportunamente;
-   ricordarsi di scrivere codice pulito e con complessità bassa (valutare la possibilità di utilizzare un plugin sonarqube o simile)
-   ricordarsi di seguire quanto qui scritto da subito per evitare di dover mettere mano al codice in più fasi successive
-   eseguire tanti ma tanti test



APPUNTI SERVIZIO API ARTSY DA NON PERDERE:
//recupero le opere dell'artista
		//picasso 4d8b928b4eb68a1b2c0001f2
		//van gogh 4d8b92944eb68a1b2c000264
		//sandro botticelli 4eaeec71bddaf7000100681b
		//michelangelo buonarroti 4d8b92834eb68a1b2c00019e
		//neruda 0 opere
		//salvador dali 4dadcce67129f059240009df 0 opere

		/*String urlGetArtworksByArtistId= appProps.getUrlEndpoint()+"artworks?artist_id=4eaeec71bddaf7000100681b";
		String opereVanGogh= executeGet(urlGetArtworksByArtistId,token);
		Gson gsonOpere = new Gson();
		ArtworksResponse artworksResponse = gsonOpere.fromJson(opereVanGogh, ArtworksResponse.class);
		List<Artwork> opere = artworksResponse.get_embedded().getArtworks();

		Desktop desk=Desktop.getDesktop();
		for (Artwork artwork : opere) {

			String idImmagine = artwork.getId();
			logger.info("Identificativo dell'opera: {}",idImmagine);

			Links links = artwork.getLinks();

			String urlImmagine = links.getImage().getHref();
			String nome = artwork.getTitle();
			urlImmagine = urlImmagine.replace("{image_version}", "large");

			//byte[] operaDArte = getImage(urlImmagine);

			logger.info("Opera d'arte recuperata: {} - url {}",nome,urlImmagine);
			//byte[] operaDArte = recuperaImmagine(urlImmagine); 
			try {
				desk.browse(new URI(urlImmagine));
			} catch (IOException | URISyntaxException e) {
				// TODO Auto-generated catch block
				e.printStackTrace();
			}
		}*/